<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nimbus Block 2.0</title>
  <style>
    /* ---------------- CSS START ---------------- */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: url('assets/backgroundblocks.png') no-repeat center center fixed;
      background-size: cover;
      font-family: system-ui,
        -apple-system,
        BlinkMacSystemFont,
        "Segoe UI",
        sans-serif;
      color: #0f172a;
      -webkit-font-smoothing: antialiased;
    }

    .nimbus-background {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .nimbus-orb {
      position: absolute;
      border-radius: 50%;
      filter: blur(50px);
      opacity: 0.15;
      /* Very subtle */
      animation: float-orb 20s infinite ease-in-out alternate;
    }

    .orb-1 {
      top: -10%;
      left: -10%;
      width: 600px;
      height: 600px;
      background: radial-gradient(circle at 50% 50%, #bfdbfe, #a855f7);
      animation-delay: 0s;
    }

    .orb-2 {
      top: 40%;
      right: -10%;
      width: 500px;
      height: 500px;
      background: radial-gradient(circle at 50% 50%, #fbbf24, #fb7185);
      animation-delay: -5s;
    }

    .orb-3 {
      bottom: -10%;
      left: 20%;
      width: 700px;
      height: 700px;
      background: radial-gradient(circle at 50% 50%, #22c55e, #0ea5e9);
      animation-delay: -10s;
    }

    @keyframes float-orb {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 0.15;
      }

      33% {
        transform: translate(30px, -50px) scale(1.1);
        opacity: 0.2;
      }

      66% {
        transform: translate(-20px, 20px) scale(0.95);
        opacity: 0.12;
      }

      100% {
        transform: translate(0, 0) scale(1);
        opacity: 0.15;
      }
    }

    .nimbus-grid::before,
    .nimbus-grid::after {
      content: "";
      position: absolute;
      inset: 12% 8%;
      border-radius: 32px;
      background-image: linear-gradient(rgba(255, 255, 255, 0.12) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.12) 1px, transparent 1px);
      background-size: 32px 32px;
      opacity: 0.15;
    }

    .nimbus-grid::after {
      inset: auto 18% 6% auto;
      width: 260px;
      height: 260px;
      background-image: radial-gradient(circle at 0 0, rgba(59, 130, 246, 0.55), transparent 60%);
      filter: blur(18px);
      opacity: 0.35;
    }

    /* Start Screen Styles */
    #startScreen {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      /* Background handled by body/nimbus-background, but we might want a slight backdrop here */
    }

    .start-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 24px;
      animation: fadeIn 0.8s ease-out;
      width: 100%;
      /* Ensure content spans full width */
    }

    .start-logo-container {
      position: relative;
      margin-bottom: 32px;
      /* Purple Banner Style: Translucent & Full Width -> NOW MATCHED TO GAME BANNER */
      background: rgba(15, 23, 42, 0.85);
      padding: 20px 0;
      /* Minimal vertical padding to fit logo */
      width: 100%;
      /* Span full width */
      max-width: none;
      border-radius: 0;
      /* No rounded corners for full width banner */
      box-shadow: 0 10px 40px rgba(255, 255, 255, 0.1), inset 0 0 0 1px rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(8px);
      /* Less blur for more translucency */

      display: flex;
      justify-content: center;
      align-items: center;
      /* Animation: Float removed/adjusted as it might look weird on a full width banner.
         Let's keep the logo floating inside optionally, or just static banner.
         User said "atraviese de un lado a otro". Usually static.
         Let's remove the float from container. */
    }

    .start-logo {
      height: 420px;
      /* Tripled from 140px */
      width: auto;
      filter: drop-shadow(0 0 50px rgba(168, 85, 247, 0.6));
      /* Enhanced glow for larger size */
    }

    .start-title {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: -0.02em;
      background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 8px;
    }

    .start-subtitle {
      font-size: 16px;
      color: #64748b;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 32px;
    }

    .start-btn {
      background: linear-gradient(135deg, #a5b4fc 0%, #818cf8 100%);
      color: white;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 0.05em;
      padding: 16px 48px;
      border-radius: 999px;
      border: none;
      box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3), inset 0 0 0 1px rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
      overflow: hidden;
    }

    .start-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.4), transparent);
      transform: skewX(-20deg) translateX(-150%);
      transition: transform 0.5s;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3), inset 0 0 0 1px rgba(255, 255, 255, 0.3);
    }

    .start-btn:hover::after {
      transform: skewX(-20deg) translateX(150%);
      transition: transform 0.7s;
    }

    .secondary-options {
      display: flex;
      gap: 16px;
      margin-top: 32px;
    }

    .sec-btn {
      background: linear-gradient(135deg, #e0f2fe, #bfdbfe);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.6);
      padding: 12px 24px;
      border-radius: 999px;
      border: none;
      outline: none;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #0f172a;
      cursor: pointer;
      backdrop-filter: blur(4px);
      /* Optional, but keeps glass feel if gradient is semi-transparent? Gradient is opaque here. */
      transition: all 0.2s;
    }

    .sec-btn:hover {
      background: linear-gradient(135deg, #dbeafe, #a5b4fc);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.8);
    }

    .sec-btn:active {
      transform: translateY(0);
      box-shadow: 0 0 0 0.7px rgba(148, 163, 184, 0.9), 0 6px 14px rgba(148, 163, 184, 0.9);
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-15px);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Hide app shell initially */
    .app-shell {
      display: none;
      /* Hidden by default */
      animation: fadeIn 0.5s ease-out;
      padding-top: 160px;
      /* Increased to clear bigger banner */
    }

    /* ---------------- CSS END ---------------- */

    .app-card {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 24px 26px 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.86), rgba(255, 255, 255, 0.78));
      border-radius: 26px;
      box-shadow: 0 40px 80px rgba(15, 23, 42, 0.22), 0 0 0 1px rgba(148, 163, 184, 0.18);
      backdrop-filter: blur(26px);
    }

    /* Game Page Banner - Fixed Top Full Width */
    .app-header {
      position: fixed;
      /* Stick to top */
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(15, 23, 42, 0.85);
      /* Matched to Game Banner */
      backdrop-filter: blur(12px);
      padding: 24px 0;
      /* Bigger padding */
      display: none;
      /* Hidden by default (shown via JS) */
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
      z-index: 100;
      /* High z-index */
      margin: 0;
    }

    .app-header::after {
      /* Remove shimmer from this banner style to keep it clean, or keep it subtle?
          User didn't explicitly ask to remove shimmer, but full width shimmer might be distracting.
          Let's remove the ::after pseudo-element for now or reset it to none. */
      content: none;
    }

    .app-title {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header-logo {
      height: 72px;
      /* Slightly larger logo to match bigger banner */
      width: auto;
      filter: drop-shadow(0 2px 10px rgba(168, 85, 247, 0.5));
    }

    @keyframes shimmer {
      0% {
        left: -100%;
      }

      20% {
        left: 200%;
      }

      100% {
        left: 200%;
      }
    }

    .app-main {
      display: grid;
      grid-template-columns: 180px 320px 180px;
      gap: 24px;
      align-items: start;
      justify-content: center;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 100%;
    }

    /* Stats Panel */
    .stats-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
      padding: 16px;
      min-height: 84px;
      flex-shrink: 0;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.9), rgba(224, 242, 254, 0.9));
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 10px 30px rgba(148, 163, 184, 0.3);
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .stat-label {
      font-size: 11px;
      letter-spacing: 0.1em;
      color: #64748b;
      text-transform: uppercase;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 20px;
      color: #0f172a;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      line-height: 1;
    }

    .divider {
      width: 1px;
      height: 32px;
      background: rgba(148, 163, 184, 0.4);
      margin: 0 12px;
    }

    /* Restored Layout Cards with v2.0 Polish */
    .playfield-card {
      padding: 16px;
      border-radius: 24px;
      width: 320px;
      flex-shrink: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.7), rgba(241, 245, 249, 0.8));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.8), 0 20px 50px rgba(100, 116, 139, 0.15);
      display: flex;
      justify-content: center;
      backdrop-filter: blur(10px);
    }

    /* Adjust Game Container - fixed size so playfield never shifts */
    .game-container {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.2), 0 10px 30px rgba(15, 23, 42, 0.15);
      width: 288px;
      height: 528px;
      height: 528px;
      flex-shrink: 0;
    }



    /* Enhancements */
    .primary-button {
      background: linear-gradient(135deg, #e0f2fe, #bfdbfe);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.6);
      margin-top: 14px;
      padding: 8px 22px;
      border-radius: 999px;
      border: none;
      outline: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #0f172a;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }

    .primary-button:hover {
      background: linear-gradient(135deg, #dbeafe, #a5b4fc);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.8);
    }

    .primary-button:active {
      transform: translateY(0);
      box-shadow: 0 0 0 0.7px rgba(148, 163, 184, 0.9), 0 6px 14px rgba(148, 163, 184, 0.9);
    }

    /* Make font smoother */
    body {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    canvas#tetris {
      display: block;
      background: radial-gradient(circle at top, #1e293b 0, #0f172a 100%);
    }

    /* Sidebar removed/merged into side-panel */

    .glass-panel {
      position: relative;
      padding: 16px;
      border-radius: 20px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.3));
      box-shadow: 0 8px 24px rgba(148, 163, 184, 0.15), inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(12px);
    }

    .glass-panel h2 {
      color: #64748b;
      font-size: 12px;
      letter-spacing: 0.15em;
      margin-bottom: 8px;
    }

    .metric-value {
      margin-top: 8px;
      font-size: 20px;
      color: #0f172a;
      font-weight: 700;
      background: none;
      box-shadow: none;
      padding: 0;
      font-variant-numeric: tabular-nums;
      min-width: 3ch;
    }

    canvas#nextPiece,
    canvas#holdPiece {
      background: rgba(15, 23, 42, 0.03);
      border-radius: 12px;
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.04);
    }

    /* Overlays V2 */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(248, 250, 252, 0.9) 0, rgba(226, 232, 240, 0.98) 55%, rgba(209, 213, 219, 1) 100%);
      color: #0f172a;
      z-index: 10;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay-content {
      text-align: center;
    }

    .overlay h2 {
      font-size: 24px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 12px;
      color: #e2e8f0;
      /* Light gray for better visibility */
    }

    .glow-text {
      font-size: 12px;
      color: #a855f7;
      margin-bottom: 20px;
      letter-spacing: 0.2em;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.4);
    }

    .controls-hint {
      margin-top: 24px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 16px;
      opacity: 0.7;
    }

    .controls-hint p {
      font-size: 11px;
      color: #475569;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border: 1px solid rgba(0, 0, 0, 0.1);
      padding: 4px 8px;
      border-radius: 6px;
    }

    .small-hint {
      font-size: 10px;
      text-align: center;
      color: #94a3b8;
      margin-top: 4px;
      text-transform: uppercase;
    }

    .pill {
      border: none;
      outline: none;
      background: transparent;
      color: #4b5563;
      padding: 5px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 160ms ease, color 160ms ease, box-shadow 160ms ease;
    }

    .pill:hover {
      background: rgba(248, 250, 252, 0.9);
    }

    @media (max-width: 720px) {
      .app-shell {
        padding: 18px 14px;
      }

      .app-card {
        flex-direction: column;
        align-items: center;
        padding: 18px 16px 16px;
      }

      .app-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .app-main {
        grid-template-columns: 1fr;
        justify-content: center;
      }

      .side-panel {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        width: 100%;
      }

      .playfield-card {
        width: 320px;
        max-width: 100%;
        order: -1;

        /* Keep board on top on mobile if desired, or let it flow naturally */



        /* Order: Board first, then panels? Or panels then board?
         On mobile, maybe Score/Next on top, Board, then Hold?
         Let's keep natural order: Left (Hold), Center (Board), Right (Next).
         But flex direction column on app-main?
      */

      }
    }

    /* Feedback Button (Global) */
    .feedback-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 24px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.25);
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      letter-spacing: 0.02em;
    }

    .feedback-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .feedback-btn svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
      opacity: 0.9;
    }

    /* Music Selection Active State */
    .music-option {
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.05);
      font-size: 11px;
      padding: 8px 4px;
    }

    .music-option.selected {
      background: rgba(168, 85, 247, 0.2);
      border-color: rgba(168, 85, 247, 0.5);
      color: #e2e8f0;
      box-shadow: 0 0 12px rgba(168, 85, 247, 0.2);
    }

    /* ---------------- CSS END ---------------- */
  </style>
</head>

<body>
  <div class="nimbus-background">
    <div class="nimbus-orb orb-1"></div>
    <div class="nimbus-orb orb-2"></div>
    <div class="nimbus-orb orb-3"></div>
    <div class="nimbus-grid"></div>
  </div>

  <a href="#" class="feedback-btn" id="feedbackBtn">
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M20 2H4C2.9 2 2 2.9 2 4V22L6 18H20C21.1 18 22 17.1 22 16V4C22 2.9 21.1 2 20 2ZM20 16H6L4 18V4H20V16Z"
        fill="currentColor" />
    </svg>
    Feedback
  </a>

  <div id="startScreen">
    <div class="start-content">
      <div class="start-logo-container">
        <img src="assets/nimbusblockslogo.png" alt="Nimbus Blocks" class="start-logo">
      </div>
      <!-- Text removed as requested -->

      <button id="mainStartBtn" class="start-btn">START GAME</button>

      <div class="secondary-options">
        <button id="btnDaily" class="sec-btn">Daily Challenge</button>
        <button id="btnSettings" class="sec-btn">Settings</button>
      </div>
    </div>

    <!-- Menu Overlays (Initially Hidden) -->


    <div class="overlay hidden" id="dailyOverlay"
      style="background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(20px);">
      <div class="overlay-content">
        <h2 style="color: #e2e8f0;">Daily Challenge</h2>
        <div class="glow-text" style="color: #c084fc;">TODAY'S GOAL</div>
        <p style="color: #cbd5e1; margin-bottom: 24px; font-size: 14px;">Clear 40 Lines in under 3 minutes.</p>
        <button id="startChallengeBtn" class="pill" style="margin-bottom: 16px;">Start Challenge</button>
        <br>
        <button id="closeDaily" class="primary-button">Back</button>
      </div>
    </div>

    <div class="overlay hidden" id="settingsOverlay"
      style="background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(20px);">
      <div class="overlay-content">
        <h2 style="color: #e2e8f0;">Settings</h2>
        <div class="controls-hint"
          style="grid-template-columns: 1fr; gap: 16px; margin-bottom: 24px; text-align: left;">

          <!-- Music Toggle -->
          <label
            style="display: flex; justify-content: space-between; color: #e2e8f0; font-size: 13px; align-items: center;">
            <span style="font-weight: 600; letter-spacing: 0.05em;">BACKGROUND MUSIC</span>
            <input type="checkbox" id="musicToggle" checked
              onchange="audio.toggleMusic(); document.getElementById('musicToggle').checked = !audio.isMusicMuted;">
          </label>

          <!-- Sound Effects Toggle -->
          <label
            style="display: flex; justify-content: space-between; color: #e2e8f0; font-size: 13px; align-items: center;">
            <span style="font-weight: 600; letter-spacing: 0.05em;">SOUND EFFECTS</span>
            <input type="checkbox" id="soundToggle" checked
              onchange="audio.toggleSound(); document.getElementById('soundToggle').checked = !audio.isSoundMuted;">
          </label>

          <div class="divider" style="width: 100%; height: 1px; background: rgba(255,255,255,0.15); margin: 8px 0;">
          </div>

          <!-- Music Selection -->
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <span
              style="color: #cbd5e1; font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em; font-weight: 600;">Background
              Melody</span>
            <div class="music-grid" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
              <button class="pill music-option selected" onclick="selectMusic('melody1', this)">
                Dreamy
              </button>
              <button class="pill music-option" onclick="selectMusic('melody2', this)">
                Arcade
              </button>
              <button class="pill music-option" onclick="selectMusic('melody3', this)">
                Focus
              </button>
            </div>
          </div>

        </div>
        <button id="closeSettings" class="primary-button">Back</button>
      </div>
    </div>
  </div>

  <header class="app-header">
    <div class="app-title">
      <img src="assets/nimbusblockslogo.png" alt="Nimbus Blocks" class="header-logo">
    </div>
  </header>

  <div class="app-shell">
    <div class="app-card">

      <!-- Stats Panel: shows Level and Lines -->
      <section class="glass-panel stats-panel" aria-label="Game Stats">
        <div class="stats-row">
          <div class="stat-item">
            <div class="stat-label">LEVEL</div>
            <div id="level" class="stat-value">1</div>
          </div>
          <div class="divider"></div>
          <div class="stat-item">
            <div class="stat-label">LINES</div>
            <div id="lines" class="stat-value">0</div>
          </div>
        </div>
      </section>

      <main class="app-main">
        <!-- LEFT COLUMN: HOLD -->
        <aside class="side-panel">
          <section class="glass-panel next-panel">
            <h2>HOLD</h2>
            <canvas id="holdPiece" width="144" height="144"></canvas>
            <p class="small-hint">Shift</p>
          </section>
        </aside>

        <!-- CENTER COLUMN: BOARD -->
        <section class="playfield-card">
          <div class="game-container">
            <canvas id="tetris"></canvas>



            <!-- Overlays -->
            <div class="overlay" id="startOverlay">
              <div class="overlay-content">
                <h2>Nimbus Block</h2>
                <div class="glow-text">VERSION 2.0</div>
                <p>Pentomino Puzzle Adventure</p>
                <div class="menu-buttons" style="display: flex; gap: 8px; justify-content: center; flex-wrap: nowrap;">
                  <button id="startButton" class="primary-button" type="button"
                    style="padding: 6px 14px; font-size: 11px;">PLAY</button>
                  <button id="instructionsButton" class="primary-button" type="button"
                    style="padding: 6px 14px; font-size: 11px;">INSTRUCTIONS</button>
                  <button id="helpButton" class="primary-button" type="button"
                    style="padding: 6px 14px; font-size: 11px;">HELP</button>
                </div>
              </div>
            </div>

            <div class="overlay hidden" id="gameOverOverlay">
              <div class="overlay-content">
                <h2>Game Over</h2>
                <p>The flow has stopped.</p>
                <button class="pill" type="button" onclick="location.reload()">Try Again</button>
              </div>
            </div>

            <div class="overlay hidden" id="pauseOverlay">
              <div class="overlay-content">
                <h2>Paused</h2>
                <div class="menu-buttons">
                  <button id="resumeButton" class="primary-button" type="button" style="width: 100%;">RESUME</button>
                  <button id="quitButton" class="pill" type="button"
                    style="margin-top: 12px; width: 100%;">QUIT</button>
                </div>
              </div>
            </div>

            <div class="overlay hidden" id="instructionsOverlay">
              <div class="overlay-content">
                <h2>Instructions</h2>
                <div class="controls-hint" style="grid-template-columns: 1fr; gap: 12px; margin-bottom: 20px;">
                  <p>‚Üê ‚Üí Move Piece</p>
                  <p>‚Üë Rotate Piece</p>
                  <p>‚Üì Soft Drop</p>
                  <p>SPACE Hard Drop</p>
                  <p>SHIFT Hold Piece</p>
                  <p>C Hold Piece</p>
                </div>
                <button id="backFromInstructions" class="primary-button" type="button">Back</button>
              </div>
            </div>

            <div class="overlay hidden" id="helpOverlay">
              <div class="overlay-content">
                <h2>Help</h2>
                <p style="font-size: 13px; margin-bottom: 16px; color: #475569;">
                  Clear lines to score points and level up.<br>
                  Game speeds up every 10 lines.
                </p>
                <div class="controls-hint" style="grid-template-columns: 1fr; margin-bottom: 20px;">
                  <p>1 Line: 100 x Level</p>
                  <p>2 Lines: 300 x Level</p>
                  <p>3 Lines: 500 x Level</p>
                  <p>4 Lines: 800 x Level</p>
                </div>
                <button id="backFromHelp" class="primary-button" type="button">Back</button>
              </div>
            </div>


          </div>
        </section>

        <!-- RIGHT COLUMN: NEXT & SCORE -->
        <aside class="side-panel">
          <section class="glass-panel metric">
            <h2>SCORE</h2>
            <div id="score" class="metric-value">0</div>
          </section>

          <div style="display: flex; gap: 8px; margin-bottom: 20px;">
            <button id="pauseButton" class="primary-button"
              style="flex: 1; margin: 0; min-width: 0; padding: 12px 8px; font-size: 13px;" type="button">
              PAUSE
            </button>
            <button id="muteButton" class="primary-button"
              style="flex: 1; margin: 0; min-width: 0; padding: 12px 8px; font-size: 13px;" type="button">
              MUTE
            </button>
          </div>

          <section class="glass-panel next-panel">
            <h2>NEXT</h2>
            <canvas id="nextPiece"></canvas>
          </section>
        </aside>
      </main>
    </div>
  </div>

  <script>
    /* ---------------- JS START ---------------- */

    // --- PIECES MODULE ---
    const PIECES = {};
    // 5 easy-to-merge shapes (different from classic Tetris I/O/T/S/Z/J/L)
    const RAW_SHAPES = {
      "square": [[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
      "corner": [[1, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
      "step": [[0, 1, 1, 0, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
      "tower": [[0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
      "plus": [[0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    };
    const PALETTE = {
      "square": "#4ade80", "corner": "#38bdf8", "step": "#fbbf24", "tower": "#a78bfa", "plus": "#f472b6"
    };
    const COLORS = {};

    function rotateMatrix(matrix) {
      const N = matrix.length;
      const res = matrix.map(row => [...row]);
      for (let i = 0; i < N / 2; i++) {
        for (let j = i; j < N - i - 1; j++) {
          const temp = res[i][j];
          res[i][j] = res[N - 1 - j][i];
          res[N - 1 - j][i] = res[N - 1 - i][N - 1 - j];
          res[N - 1 - i][N - 1 - j] = res[j][N - 1 - i];
          res[j][N - 1 - i] = temp;
        }
      }
      return res;
    }
    Object.keys(RAW_SHAPES).forEach(key => {
      const rot0 = RAW_SHAPES[key];
      const rot90 = rotateMatrix(rot0);
      const rot180 = rotateMatrix(rot90);
      const rot270 = rotateMatrix(rot180);
      PIECES[key] = [rot0, rot90, rot180, rot270];
      COLORS[key] = PALETTE[key] || "#94a3b8";
    });

    // --- MISSIONS MODULE ---


    // --- AUDIO SYSTEM ---
    class AudioSystem {
      constructor() {
        // Web Audio Context for sound effects
        this.ctx = null;
        this.masterGain = null;
        this.sfxGain = null;
        this.initialized = false;

        // HTML5 Audio for background music (avoids CORS issues with file://)
        this.bgmAudio = null;
        this.currentBgmAudio = null;
        this.isMusicMuted = false;  // Separate mute state for music
        this.isSoundMuted = false;  // Separate mute state for sound effects

        // Sound Effects (will use Web Audio API)
        this.sounds = {};

        // Music Tracks Configuration
        this.tracks = {
          melody1: { name: "Dreamy", path: "assets/Falling Blocks Fever.mp3" },
          melody2: { name: "Arcade", path: "assets/Falling Blocks, Rising Score.mp3" },
          melody3: { name: "Focus", path: "assets/Thought Spiral.mp3" }
        };
        this.currentTrackId = localStorage.getItem("nimbus_music_track") || "melody1";

        // Create the HTML5 audio element for music
        this.bgmAudio = new Audio();
        this.bgmAudio.loop = true;
        this.bgmAudio.volume = 0.3; // 30% volume for music
        console.log("AudioSystem constructor completed");
      }

      init() {
        if (this.initialized) return;

        // Initialize Web Audio Context for sound effects only
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();

        // Master gain (controls overall SFX volume)
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);

        // SFX gain (controls sound effects separately)
        this.sfxGain = this.ctx.createGain();
        this.sfxGain.gain.value = 0.5; // SFX at 50% of master
        this.sfxGain.connect(this.masterGain);

        this.initialized = true;
        console.log("AudioSystem initialized (Web Audio for SFX, HTML5 Audio for Music)");

        // Apply mute states
        if (this.isMusicMuted) {
          this.bgmAudio.volume = 0;
        }
        if (this.isSoundMuted) {
          this.sfxGain.gain.value = 0;
        }
      }

      setMelody(trackId) {
        if (!this.tracks[trackId]) return;
        this.currentTrackId = trackId;
        localStorage.setItem("nimbus_music_track", trackId);
        console.log(`Melody changed to: ${this.tracks[trackId].name}`);

        // Stop current music
        this.stopMusic();

        // If initialized and not muted, start the new track
        if (this.initialized && !this.isMusicMuted) {
          this.startMusic();
        }
      }

      async loadSound(name, url) {
        if (!this.ctx) return;
        try {
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
          this.sounds[name] = audioBuffer;
          console.log(`Sound ${name} loaded`);
        } catch (e) {
          console.warn(`Sound ${name} failed to load`, e);
        }
      }

      startMusic() {
        console.log("startMusic() called");

        const track = this.tracks[this.currentTrackId];
        if (!track) {
          console.error("Invalid track ID");
          return;
        }

        console.log(`Loading music: ${track.name} from ${track.path}`);

        // Set the source and play
        this.bgmAudio.src = track.path;
        this.bgmAudio.volume = this.isMusicMuted ? 0 : 0.3;

        // Play the audio (returns a promise)
        this.bgmAudio.play()
          .then(() => {
            console.log(`Music started playing: ${track.name}`);
          })
          .catch(err => {
            console.error("Music playback failed:", err);
          });
      }

      stopMusic() {
        if (this.bgmAudio) {
          this.bgmAudio.pause();
          this.bgmAudio.currentTime = 0;
          console.log("Music stopped");
        }
      }

      toggleMusic() {
        this.isMusicMuted = !this.isMusicMuted;

        // Mute/unmute music
        if (this.bgmAudio) {
          this.bgmAudio.volume = this.isMusicMuted ? 0 : 0.3;
        }

        console.log(`Music ${this.isMusicMuted ? 'muted' : 'unmuted'}`);
        return this.isMusicMuted;
      }

      toggleSound() {
        this.isSoundMuted = !this.isSoundMuted;

        // Mute/unmute SFX
        if (this.sfxGain) {
          this.sfxGain.gain.value = this.isSoundMuted ? 0 : 0.5;
        }

        console.log(`Sound effects ${this.isSoundMuted ? 'muted' : 'unmuted'}`);
        return this.isSoundMuted;
      }

      // Legacy method for backwards compatibility
      toggleMute() {
        // Toggle both music and sound together
        this.isMusicMuted = !this.isMusicMuted;
        this.isSoundMuted = this.isMusicMuted;

        // Apply to music
        if (this.bgmAudio) {
          this.bgmAudio.volume = this.isMusicMuted ? 0 : 0.3;
        }

        // Apply to SFX
        if (this.sfxGain) {
          this.sfxGain.gain.value = this.isSoundMuted ? 0 : 0.5;
        }

        console.log(`Audio ${this.isMusicMuted ? 'muted' : 'unmuted'}`);
        return this.isMusicMuted;
      }

      // Play a sound effect
      playSound(soundName) {
        if (!this.initialized || !this.sounds[soundName] || this.isSoundMuted) return;

        const source = this.ctx.createBufferSource();
        source.buffer = this.sounds[soundName];
        source.connect(this.sfxGain);
        source.start(0);
      }
    }

    const audio = new AudioSystem();

    // --- UI MODULE ---
    class UI {
      constructor(game) {
        this.game = game;
        this.scoreEl = document.getElementById("score");
        this.levelEl = document.getElementById("level");
        this.linesEl = document.getElementById("lines");
        this.screens = {
          start: document.getElementById("startOverlay"), // Needed to hide it on Game.start()
          gameOver: document.getElementById("gameOverOverlay"),
          pause: document.getElementById("pauseOverlay"),
          instructions: document.getElementById("instructionsOverlay"),
          help: document.getElementById("helpOverlay")
        };
        // this.showScreen("start"); // Don't show start overlay, main start screen is default
      }

      updateHUD(state) {
        if (state.score !== undefined && this.scoreEl) {
          this.scoreEl.textContent = state.score.toLocaleString();
        }
        if (state.level !== undefined && this.levelEl) {
          this.levelEl.textContent = state.level;
        }
        if (state.lines !== undefined && this.linesEl) {
          this.linesEl.textContent = state.lines;
        }
      }

      showScreen(name) {
        Object.values(this.screens).forEach(el => {
          if (el) el.classList.add("hidden");
        });
        const target = this.screens[name];
        if (target) target.classList.remove("hidden");
      }

      hideScreens() {
        Object.values(this.screens).forEach(el => {
          if (el) el.classList.add("hidden");
        });
      }
    }

    // --- GAME MODULE ---
    const COLS = 12;
    const ROWS = 22;
    const BLOCK_SIZE = 24;

    class Game {
      constructor() {
        this.canvas = document.getElementById("tetris");
        this.ctx = this.canvas.getContext("2d");
        this.nextCanvas = document.getElementById("nextPiece");
        this.nextCtx = this.nextCanvas.getContext("2d");
        this.holdCanvas = document.getElementById("holdPiece");
        this.holdCtx = this.holdCanvas ? this.holdCanvas.getContext("2d") : null;

        this.resizeCanvas();

        this.ui = new UI(this);
        // Missions removed for Marathon mode
        // this.missions = new MissionSystem();

        this.arena = this.createMatrix(COLS, ROWS);

        this.player = {
          pos: { x: 0, y: 0 },
          matrix: null,
          color: null,
          shapeId: null,
          pieceQ: [],
          hold: null,
          canHold: true,
          didRotate: false
        };

        this.refillQueue();
        this.renderPos = { x: 0, y: 0 };
        this.score = 0;
        this.segmentsCleared = 0;
        this.dropCounter = 0;
        this.dropInterval = 1000;
        this.lastTime = 0;
        this.isRunning = false;
        this.isPaused = false;

        this.inputHandler = this.handleInput.bind(this);
        document.addEventListener("keydown", this.inputHandler);

        const pauseBtn = document.getElementById("pauseButton");
        if (pauseBtn) {
          pauseBtn.addEventListener("click", () => {
            if (this.isRunning) {
              this.togglePause();
              pauseBtn.textContent = this.isPaused ? "RESUME" : "PAUSE";
            }
          });
        }

        const startBtn = document.getElementById("startButton");
        if (startBtn) {
          startBtn.addEventListener("click", () => {
            console.log("Start Clicked");
            this.start();
          });
        }

        // Start Screen Logic
        const startScreen = document.getElementById("startScreen");
        const appShell = document.querySelector(".app-shell");
        const appHeader = document.querySelector(".app-header");
        const mainStartBtn = document.getElementById("mainStartBtn");

        mainStartBtn.addEventListener("click", () => {
          // Initialize audio on first user interaction (browser requirement)
          if (!audio.initialized) {
            audio.init();
          }

          startScreen.style.display = "none";
          appShell.style.display = "flex";
          appHeader.style.display = "flex";
          this.start();
        });

        // Helper to show/hide overlays on Start Screen
        function toggleOverlay(id, show) {
          const el = document.getElementById(id);
          if (el) {
            if (show) el.classList.remove("hidden");
            else el.classList.add("hidden");
          }
        }




        document.getElementById("btnDaily")?.addEventListener("click", () => toggleOverlay("dailyOverlay", true));
        document.getElementById("closeDaily")?.addEventListener("click", () => toggleOverlay("dailyOverlay", false));

        // Start Challenge button
        document.getElementById("startChallengeBtn")?.addEventListener("click", () => {
          toggleOverlay("dailyOverlay", false);
          startScreen.style.display = "none";
          appShell.style.display = "flex";
          appHeader.style.display = "flex";

          // Initialize audio if needed
          if (!audio.initialized) {
            audio.init();
          }

          // Start game in challenge mode
          game.startChallenge();
        });

        document.getElementById("btnSettings")?.addEventListener("click", () => {
          // Initialize audio on first interaction (required for browser autoplay policy)
          if (!audio.initialized) {
            audio.init();
          }

          // Initialize/Update UI state
          const toggle = document.getElementById("musicToggle");
          if (toggle) toggle.checked = !audio.isMuted;

          // Update selected music
          document.querySelectorAll(".music-option").forEach(btn => btn.classList.remove("selected"));
          const current = audio.currentTrackId;
          // Find button index
          const btns = document.querySelectorAll(".music-option"); // Assuming 0=melody1, 1=melody2... or use data attribute logic
          if (current === 'melody1') btns[0].classList.add("selected");
          else if (current === 'melody2') btns[1].classList.add("selected");
          else if (current === 'melody3') btns[2].classList.add("selected");

          toggleOverlay("settingsOverlay", true);
        });
        document.getElementById("closeSettings")?.addEventListener("click", () => toggleOverlay("settingsOverlay", false));

        // Global helpers
        window.selectMusic = (id, el) => {
          // Update UI
          document.querySelectorAll(".music-option").forEach(btn => btn.classList.remove("selected"));
          el.classList.add("selected");

          // Set melody (this will stop current and load new track)
          audio.setMelody(id);

          // If audio is initialized and not muted, start playing the preview
          if (audio.initialized && !audio.isMuted) {
            audio.startMusic();
          }
        };

        // Global Music Toggle
        window.toggleMusic = (checkbox) => {
          if (checkbox.checked) {
            if (audio.isMuted) audio.toggleMute();
            if (!audio.bgmSource && audio.initialized) audio.startMusic();
          } else {
            if (!audio.isMuted) audio.toggleMute();
          }
        };

        // UI Event Listeners
        document.getElementById("instructionsButton")?.addEventListener("click", () => this.ui.showScreen("instructions"));
        document.getElementById("helpButton")?.addEventListener("click", () => this.ui.showScreen("help"));
        document.getElementById("backFromInstructions")?.addEventListener("click", () => this.ui.showScreen("start"));
        document.getElementById("backFromHelp")?.addEventListener("click", () => this.ui.showScreen("start"));

        document.getElementById("muteButton")?.addEventListener("click", (e) => {
          const muted = audio.toggleMute();
          e.target.textContent = muted ? "UNMUTE" : "MUTE";
        });
        document.getElementById("resumeButton")?.addEventListener("click", () => this.togglePause());
        document.getElementById("quitButton")?.addEventListener("click", () => this.quit());
      }

      resizeCanvas() {
        this.canvas.width = COLS * BLOCK_SIZE;
        this.canvas.height = ROWS * BLOCK_SIZE;
        this.canvas.style.width = `${COLS * BLOCK_SIZE}px`;
        this.canvas.style.height = `${ROWS * BLOCK_SIZE}px`;

        this.nextCanvas.width = 6 * BLOCK_SIZE;
        this.nextCanvas.height = 11 * BLOCK_SIZE; // Reduced to fit 2 pieces better
      }

      createMatrix(w, h) {
        const m = [];
        while (h--) m.push(new Array(w).fill(0));
        return m;
      }

      start() {
        try {
          this.arena.forEach(row => row.fill(0));
          this.score = 0;
          this.level = 1;
          this.lines = 0;
          this.linesToNextLevel = 10;
          this.segmentsCleared = 0;
          this.dropInterval = 1000;
          this.isRunning = true;
          this.isPaused = false;

          // this.missions = new MissionSystem();
          this.player.pieceQ = [];
          this.player.hold = null;
          this.player.canHold = true;
          this.refillQueue();

          this.spawnPiece();
          this.ui.hideScreens();
          this.ui.updateHUD({ score: 0, level: this.level, lines: 0 });
          this.drawQueue();

          try {
            audio.startMusic();
            // audio.playSound("mission_complete");
          } catch (e) { console.warn(e); }

          this.update();
        } catch (e) { console.error(e); }
      }

      startChallenge() {
        try {
          // Reset game state
          this.arena.forEach(row => row.fill(0));
          this.score = 0;
          this.level = 1;
          this.lines = 0;
          this.linesToNextLevel = 10;
          this.segmentsCleared = 0;
          this.dropInterval = 1000;
          this.isRunning = true;
          this.isPaused = false;

          // Challenge mode specific
          this.isChallengeMode = true;
          this.challengeGoal = 40; // 40 lines
          this.challengeTimeLimit = 180; // 3 minutes in seconds
          this.challengeStartTime = Date.now();
          this.challengeTimerInterval = null;

          // Reset player state
          this.player.pieceQ = [];
          this.player.hold = null;
          this.player.canHold = true;
          this.refillQueue();

          this.spawnPiece();
          this.ui.hideScreens();
          this.ui.updateHUD({ score: 0, level: this.level, lines: 0 });
          this.drawQueue();

          // Start challenge timer
          this.startChallengeTimer();

          try {
            audio.startMusic();
          } catch (e) { console.warn(e); }

          this.update();
        } catch (e) { console.error(e); }
      }

      startChallengeTimer() {
        // Update timer every second
        this.challengeTimerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - this.challengeStartTime) / 1000);
          const remaining = Math.max(0, this.challengeTimeLimit - elapsed);

          // Update timer display
          const minutes = Math.floor(remaining / 60);
          const seconds = remaining % 60;
          const timerDisplay = `${minutes}:${seconds.toString().padStart(2, '0')}`;

          // Update UI (you can add a timer element to the HUD)
          const timerEl = document.getElementById('challengeTimer');
          if (timerEl) {
            timerEl.textContent = timerDisplay;
          }

          // Check if time is up
          if (remaining === 0) {
            this.endChallenge(false); // Failed - time's up
          }
        }, 1000);
      }

      endChallenge(success) {
        // Stop timer
        if (this.challengeTimerInterval) {
          clearInterval(this.challengeTimerInterval);
          this.challengeTimerInterval = null;
        }

        this.isChallengeMode = false;
        this.isRunning = false;

        // Show result
        if (success) {
          alert(`üéâ Challenge Complete! You cleared ${this.lines} lines in time!`);
        } else {
          alert(`‚è∞ Time's up! You cleared ${this.lines} lines. Goal was ${this.challengeGoal} lines.`);
        }

        // Return to start screen
        const startScreen = document.getElementById("startScreen");
        const appShell = document.querySelector(".app-shell");
        const appHeader = document.querySelector(".app-header");

        if (startScreen) startScreen.style.display = "flex";
        if (appShell) appShell.style.display = "none";
        if (appHeader) appHeader.style.display = "none";
      }

      refillQueue() {
        const shapes = Object.keys(PIECES);
        while (this.player.pieceQ.length < 5) {
          const shapeId = shapes[Math.floor(Math.random() * shapes.length)];
          this.player.pieceQ.push({
            shapeId,
            rotations: PIECES[shapeId],
            color: COLORS[shapeId]
          });
        }
      }

      spawnPiece() {
        const next = this.player.pieceQ.shift();
        this.refillQueue();

        this.player.matrix = next.rotations[0];
        this.player.rotations = next.rotations;
        this.player.rotIndex = 0;
        this.player.color = next.color;
        this.player.shapeId = next.shapeId;

        this.player.pos.y = 0;
        this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);

        this.renderPos.x = this.player.pos.x;
        this.renderPos.y = this.player.pos.y;
        this.player.didRotate = false;
        this.player.canHold = true;

        if (this.collide(this.arena, this.player)) {
          this.gameOver();
        }
        this.drawQueue();
      }

      collide(arena, player) {
        const [m, o] = [player.matrix, player.pos];
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }

      merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              arena[y + player.pos.y][x + player.pos.x] = { color: player.color, shapeId: player.shapeId };
            }
          });
        });
        audio.playSound("land");
        if (this.checkClears()) return;
      }

      rotate(dir) {
        const pos = this.player.pos.x;
        let offset = 1;
        const nextIdx = (this.player.rotIndex + dir + 4) % 4;
        const nextMatrix = this.player.rotations[nextIdx];
        const oldMatrix = this.player.matrix;
        this.player.matrix = nextMatrix;
        while (this.collide(this.arena, this.player)) {
          this.player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if (offset > this.player.matrix[0].length) {
            this.player.matrix = oldMatrix;
            this.player.pos.x = pos;
            return;
          }
        }
        this.player.rotIndex = nextIdx;
        this.player.didRotate = true;
        audio.playSound("rotate");
      }

      move(dir) {
        this.player.pos.x += dir;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.x -= dir;
        } else {
          audio.playSound("move");
        }
      }

      drop() {
        this.player.pos.y++;
        if (this.collide(this.arena, this.player)) {
          this.player.pos.y--;
          this.merge(this.arena, this.player);
          // Check clears is called inside merge for scoring logic, but if not:
          // merge calls checkClears which calls spawnPiece
          // We need to ensure we don't spawn twice.
          // The original code called checkClears then spawnPiece.
          // Let's stick to original flow but wrapped in merge?
          // Wait, original drop() called merge, then checkClears, then spawnPiece.
          // BUT input space hardDrop ALSO does this.
          // So merge() just places blocks.

          this.checkClears();
          this.spawnPiece();
        }
        this.dropCounter = 0;
      }

      hardDrop() {
        while (!this.collide(this.arena, this.player)) {
          this.player.pos.y++;
        }
        this.player.pos.y--;
        this.merge(this.arena, this.player);
        this.checkClears();
        this.spawnPiece();
      }

      holdPiece() {
        if (!this.player.canHold) return;
        const current = {
          shapeId: this.player.shapeId,
          rotations: this.player.rotations,
          color: this.player.color
        };
        if (!this.player.hold) {
          this.player.hold = current;
          this.spawnPiece();
        } else {
          const swap = this.player.hold;
          this.player.hold = current;
          this.player.matrix = swap.rotations[0];
          this.player.rotations = swap.rotations;
          this.player.rotIndex = 0;
          this.player.color = swap.color;
          this.player.shapeId = swap.shapeId;
          this.player.pos.y = 0;
          this.player.pos.x = (this.arena[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);
          this.player.didRotate = false;
        }
        this.player.canHold = false;
        this.drawHold();
      }

      checkClears() {
        let linesCleared = 0;

        // Iterate from bottom to top
        outer: for (let y = this.arena.length - 1; y > 0; --y) {
          for (let x = 0; x < this.arena[y].length; ++x) {
            if (this.arena[y][x] === 0) {
              continue outer;
            }
          }

          const row = this.arena.splice(y, 1)[0].fill(0);
          this.arena.unshift(row);
          ++y;
          linesCleared++;
        }

        if (linesCleared > 0) {
          audio.playSound("clear");

          // Marathon Scoring
          const baseScores = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
          const scoreIncrease = (baseScores[linesCleared] || (linesCleared * 200)) * this.level;
          this.score += scoreIncrease;
          this.lines += linesCleared;

          // Level Up
          if (this.lines >= this.level * 10) {
            this.level++;
            audio.playSound("level_up");
            // Speed up
            let newInterval = 1000 - (this.level - 1) * 100;
            if (newInterval < 50) newInterval = 50;
            this.dropInterval = newInterval;
          }

          this.ui.updateHUD({ score: this.score, level: this.level, lines: this.lines });

          // Check if challenge goal is reached
          if (this.isChallengeMode && this.lines >= this.challengeGoal) {
            this.endChallenge(true); // Success!
          }
        }
      }

      gameOver() {
        this.isRunning = false;
        audio.playSound("gameover");
        audio.stopMusic();
        this.ui.showScreen("gameOver");
      }

      quit() {
        this.isRunning = false;
        this.isPaused = false;
        audio.stopMusic();

        // Hide game shell, show start screen
        document.querySelector(".app-shell").style.display = "none";
        const appHeader = document.querySelector(".app-header");
        if (appHeader) appHeader.style.display = "none"; // Hide game banner
        document.getElementById("startScreen").style.display = "flex";

        // Also reset internal UI state just in case
        this.ui.hideScreens();
        document.getElementById("startOverlay").classList.remove("hidden"); // Reset for next time
      }

      togglePause() {
        if (!this.isRunning) return;
        this.isPaused = !this.isPaused;
        if (this.isPaused) {
          this.ui.showScreen("pause");
          audio.stopMusic();
        } else {
          this.ui.hideScreens();
          audio.startMusic();
        }
      }

      update(time = 0) {
        if (!this.isRunning || this.isPaused) {
          this.lastTime = time;
          requestAnimationFrame(this.update.bind(this));
          return;
        }

        const deltaTime = time - this.lastTime;
        this.lastTime = time;
        this.dropCounter += deltaTime;

        // if (this.missions.updateTime()) {
        //   this.checkMission(true);
        // }
        // this.ui.updateHUD({ mission: this.missions.activeMission });

        if (this.dropCounter > this.dropInterval) {
          this.drop();
        }

        const lerpSpeed = 0.2;
        this.renderPos.x += (this.player.pos.x - this.renderPos.x) * lerpSpeed;
        this.renderPos.y += (this.player.pos.y - this.renderPos.y) * lerpSpeed;

        this.draw();
        requestAnimationFrame(this.update.bind(this));
      }

      draw() {
        this.ctx.fillStyle = "#020617";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.strokeStyle = "rgba(255, 255, 255, 0.04)";
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for (let i = 0; i <= COLS; i++) {
          this.ctx.moveTo(i * BLOCK_SIZE, 0);
          this.ctx.lineTo(i * BLOCK_SIZE, this.canvas.height);
        }
        for (let i = 0; i <= ROWS; i++) {
          this.ctx.moveTo(0, i * BLOCK_SIZE);
          this.ctx.lineTo(this.canvas.width, i * BLOCK_SIZE);
        }
        this.ctx.stroke();

        this.drawMatrix(this.arena, { x: 0, y: 0 });

        if (this.player.matrix) {
          this.drawMatrix(this.player.matrix, this.renderPos, this.player.color);
        }
      }

      drawQueue() {
        this.nextCtx.fillStyle = "#0f172a";
        this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
        let yOffset = 1;
        this.player.pieceQ.slice(0, 2).forEach(piece => {
          const matrix = piece.rotations[0];
          const xOffset = (6 - matrix[0].length) / 2;
          this.drawMatrixOnCtx(this.nextCtx, matrix, { x: xOffset, y: yOffset }, piece.color);
          yOffset += 5;
        });
      }

      drawHold() {
        if (!this.holdCtx) return;
        this.holdCtx.fillStyle = "#0f172a";
        this.holdCtx.fillRect(0, 0, this.holdCanvas.width, this.holdCanvas.height);
        if (this.player.hold) {
          const matrix = this.player.hold.rotations[0];
          const xOffset = (6 - matrix[0].length) / 2;
          const yOffset = (6 - matrix.length) / 2;
          this.drawMatrixOnCtx(this.holdCtx, matrix, { x: xOffset, y: yOffset }, this.player.hold.color);
        }
      }

      drawMatrix(matrix, offset, overrideColor = null) {
        this.drawMatrixOnCtx(this.ctx, matrix, offset, overrideColor);
      }

      drawMatrixOnCtx(ctx, matrix, offset, overrideColor = null) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              const color = overrideColor || (typeof value === 'object' ? value.color : value);
              if (color) {
                this.drawGlassBlock(ctx, (x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, color);
              }
            }
          });
        });
      }

      drawGlassBlock(ctx, x, y, color) {
        const size = BLOCK_SIZE;
        const pad = 1.5;
        ctx.save();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(x + pad, y + pad, size - pad * 2, size - pad * 2);
        ctx.globalAlpha = 1.0;
        ctx.shadowColor = color;
        ctx.shadowBlur = 8;
        const grad = ctx.createLinearGradient(x, y, x, y + size);
        grad.addColorStop(0, "rgba(255,255,255,0.7)");
        grad.addColorStop(0.4, "rgba(255,255,255,0)");
        ctx.fillStyle = grad;
        ctx.fillRect(x + pad, y + pad, size - pad * 2, size / 2);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 1;
        ctx.strokeRect(x + pad, y + pad, size - pad * 2, size - pad * 2);
        ctx.restore();
      }

      handleInput(event) {
        const gameKeys = ["ArrowLeft", "ArrowRight", "ArrowDown", "ArrowUp", "Space", "KeyC", "ShiftLeft"];
        if (gameKeys.includes(event.code)) {
          event.preventDefault();
        }
        if (!this.isRunning || this.isPaused) return;
        switch (event.code) {
          case "ArrowLeft": this.move(-1); break;
          case "ArrowRight": this.move(1); break;
          case "ArrowDown": this.drop(); break;
          case "ArrowUp": this.rotate(1); break;
          case "Space": this.hardDrop(); break;
          case "KeyC":
          case "ShiftLeft":
            this.holdPiece();
            break;
        }
      }
    }

    // Initial Launch
    const game = new Game();
  </script>
</body>

</html>